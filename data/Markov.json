{
  "class": "rita.Markov",
  "fields": [],
  "statics": [
    {
      "name": "fromJSON",
      "example": "rm = Markov.fromJSON(jsonData);",
      "description": "Loads a model previously saved as JSON",
      "syntax": "Markov.fromJSON(jsonData);",
      "parameters": [
        {
          "type": "String",
          "desc": "a JSON string containing the model"
        }
      ],
      "returns": [
        {
          "type": "Markov",
          "desc": "a newly created Markov object"
        }
      ],
      "related": "",
      "platform": "JavaScript",
      "note": "This API not available in Java yet"
    }
  ],
  "functions": [
    {
      "name": "Markov",
      "example": "text = \"This is a example of two sentences. This is the second one. \"<br><br>rm = new Markov(3);<br><br>rm.addText(text);<br><br>sentences = rm.generate(2);<br><br>for (let i = 0; i < sentences.length; i ++ ){<br>  println(sentences[i]);<br>}",
      "description": "Performs text generation via Markov chains (aka n-grams) with options to process single characters, words, sentences, or arbitrary regular expressions.<br><br>Provides a variety of methods specifically designed for text-generation.",
      "syntax": "// Constructs a sentence-generating Markov-chain and set its n-factor.<br><br>Markov(nFactor);<br><br>// Also add options to the model<br><br>Markov(nFactor, options);",
      "parameters": [
        {
          "type": "int",
          "desc": "n-factor -- the length of each n-gram stored in the model"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "options for creating the model (optional)<br><br>{Function} options.tokenizer:<br>a customerized tokenizer for the model<br><br>{boolean} options.trace:<br>if true, output debug log to console<br><br>{int} options.maxAttempts:<br>max attempts before throwing error in generation, default=99<br><br>{boolean} options.disableInputChecks:<br>if true, allow result to be in input<br><br>{int} options.maxLengthMatch:<br># of words allowed in result to match with a sequence in input, default=0<br><br>{Function} options.untokenizer(only in JavaScript):<br>customized untokenizer for the model"
        }
      ],
      "returns":[
        {
          "type": "Markov",
          "desc": "a Markov object"
        }
      ],
      "platform": "Java / JavaScript"
    },
    {
      "name": "addText",
      "example": "sample = \"One reason people lie is to achieve personal power.\";<br/>rm = new Markov(3);<br/>rm.addText(sample);<br/> OR <br/>rm.addText(sentencesArray);",
      "description": "Loads text into the model. If a raw string is provided, it will be split into sentences (using RiTa.sentences(). If an array is provided, each string is treated as an individual sentence.",
      "syntax": "addText(text);<br/>addText(text, multiplier);",
      "parameters": [
        {
          "type": "String or String[]",
          "desc": "an array of sentences or the raw text to be split into sentences"
        },
        {
          "type": "int",
          "desc": "weighting for text (optional, default=1) "
        }
      ],
      "returns": [
        {
          "type": "Markov",
          "desc": "this Markov"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "completions",
      "example": "result = rm.completions([ &#34;the&#34;,&#34;red&#34;]);<br/>&nbsp;<br/>result = rm.completions([ &#34;the&#34; ], [ &#34;red&#34;, &#34;ball&#34; ]);",
      "syntax": "completions(preArray);<br/>completions(preArray, postArray);",
      "description": "If only one array parameter is provided, this function returns all possible next words, ordered by probability, for the given array.<br/>&nbsp;<br/>If two arrays are provided, it returns an unordered list of possible words <i>w</i> that complete the n-gram consisting of: pre[0]...pre[k], <i>w</i>, post[k+1]...post[n].<br/><br/><pre>result = rm.completions([ &#34;the&#34; ], [ &#34;red&#34;, &#34;ball&#34; ]);</pre>will return all the single words that occur between 'the' and 'red ball' in the current model (assuming n > 3),e.g., [ 'round', 'big', 'bouncy']).<br/><br/>Note: For this operation to be valid, (pre.length + post.length) must be less than the model's n-factor, otherwise an error will be thrown.",
      "parameters": [
        {
          "type": "String[]",
          "desc": "pre"
        },
        {
          "type": "String[]",
          "desc": "post (optional)"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "an unordered list of possible next tokens"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "generate",
      "example": "rm = new Markov(3);<br/>rm.addText(sentences);<br/>sentss = rm.generate(10);",
      "description": "Generates sentences from the model.<br/>&nbsp;<br/>Note: multiple sentences generated by this method WILL follow the model across sentence boundaries; thus the following two calls are not equivalent:<br/>&nbsp;<br/><pre>results = markov.generate(10);<br/>// and<br/>for (int i = 0; i < 10; i++)<br/> results[i] = markov.generate(1);</pre>The latter will create 10 sentences with no explicit relationship between one and the next; while the former will follow probabilities from one sentence to the next.",
      "syntax": "generate(num);",
      "parameters": [
        {
          "type": "int",
          "desc": "the number of sentences (optional, default=1)"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "the options for generation (optional)<br><br>{int} options.minLength:<br>minimal length of the sentences, default=5<br><br>{int} options.maxLength:<br>maximum length of the sentences, default=35<br><br>{float} options.tempeture:<br>tempeture to control the random level<br><br>{boolean} options.allowDuplicates:<br>if true, allow result to have duplicated sentences<br><br>{String} options.startTokens:<br>tokens as the beginning of the result"
        }
      ],
      "returns": [
        {
          "type": "String[]",
          "desc": "the result"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "probability",
      "example": "rm = new Markov(3); <br/>rm.text(theText);<br/>rm.probability(\"the\");",
      "description": "Returns either the raw (unigram) probability for a single token in the model (0 if it does not exist) <br/>&nbsp;<br/>OR <br/>&nbsp;<br/>(for an array) the probability of obtaining a sequence of k tokens where k <= nFactor ,<br/>e.g., if nFactor = 3, then valid lengths for the data array are 1, 2 & 3.",
      "syntax": "probability(dataString);<br/>probability(dataArray);",
      "parameters": [
        {
          "type": "String OR String[]",
          "desc": "the string (or sequence) to search for"
        }
      ],
      "returns": [
        {
          "type": "float(when parameter is an array)<br>double(when parameter is a String object)",
          "desc": "probability from 0-1"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "probabilities",
      "example": "rm = new Markov(3); <br/>rm.loadText(theText);<br/>rm.probabilities([\"be\", \"thought\"]);",
      "description": "Returns the full set of possible next tokens as a map, given an array of tokens representing the path down the tree (with length less than n).<br/>&nbsp;<br/>Note: seed arrays of any size (>0) may be input, but only the last n-1 elements will be considered.   ",
      "syntax": "probabilities(pathString);<br/>probabilities(pathArray);<br>probabilities(pathString, temperature);<br>probabilities(pathArray, temperature);",
      "parameters": [
        {
          "type": "String OR String[]",
          "desc": "a single token or array of tokens (strings)"
        },
        {
          "type": "double",
          "desc": "temperature (optional)"
        }
      ],
      "returns": [
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "An object (JS) or HashMap (Java) mapping words to probabilities"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "size",
      "example": "rm = new Markov(3);<br/>rm.addText(sentences); if (rm.size() > 10) { ... }",
      "description": "Returns the number of tokens currently in the model",
      "syntax": "rm.size();",
      "parameters": [],
      "returns": [
        {
          "type": "int",
          "desc": ""
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "toString",
      "example": "rm = new Markov(3);<br/>rm.addText(sentences);<br/>s = rm.toString();",
      "description": "Returns a formatted version of this model",
      "syntax": "rm.toString();",
      "parameters": [],
      "returns": [
        {
          "type": "String",
          "desc": "this object as a String"
        }
      ],
      "related": "",
      "platform": "Java / JavaScript",
      "note": ""
    },
    {
      "name": "toJSON",
      "example": "rm = new Markov(3);<br/>rm.addText(sentences);<br/>json = rm.toJSON();",
      "description": "Persists the model in JSON format",
      "syntax": "toJSON();",
      "parameters": [],
      "returns": [
        {
          "type": "String",
          "desc": "JSON representation"
        }
      ],
      "related": "",
      "platform": "JavaScript",
      "note": "This API not available in Java yet"
    }
  ],
  "classDesc": [
    {
      "description": "Performs text generation via Markov chains (aka n-grams) with options to process single characters, words, sentences, or arbitrary regular expressions.<br><br>Provides a variety of methods specifically designed for text-generation.",
      "example": "text = \"This is a example of two sentences. This is the second one. \"<br><br>rm = new Markov(3);<br><br>rm.addText(text);<br><br>sentences = rm.generate(2);<br><br>for (let i = 0; i < sentences.length; i ++ ){<br>  println(sentences[i]);<br>}",
      "parameters": [
        {
          "type": "int",
          "desc": "n-factor -- the length of each n-gram stored in the model"
        },
        {
          "type": "Object<br>(or Map in Java)",
          "desc": "options for creating the model (optional)<br><br>{Function} options.tokenizer:<br>a customerized tokenizer for the model<br><br>{boolean} options.trace:<br>if true, output debug log to console<br><br>{int} options.maxAttempts:<br>max attempts before throwing error in generation, default=99<br><br>{boolean} options.disableInputChecks:<br>if true, allow result to be in input<br><br>{int} options.maxLengthMatch:<br># of words allowed in result to match with a sequence in input, default=0<br><br>{Function} options.untokenizer(only in JavaScript):<br>customized untokenizer for the model"
        }
      ],
      "returns":[],
      "syntax": "// Constructs a sentence-generating Markov-chain and set its n-factor.<br><br>Markov(nFactor);<br><br>// Also add options to the model<br><br>Markov(nFactor, options);",
      "platform": "Java / JavaScript"
    }
  ]
}