{
  "class": "rita.RiTa",
  "fields": [
    {
      "name": "VERSION",
      "example": "versionNumber = RiTa.VERSION; ",
      "variable": true,
      "description": "the current RiTa version ",
      "syntax": "RiTa.VERSION",
      "parameters": [],
      "returns": [
        {
          "type": "string",
          "desc": ""
        }
      ]
    }
  ],
  "statics": [
    {
      "name": "isAbbreviation",
      "example": "RiTa.isAbbreviation(\"Prof.\"); // returns -> true",
      "description": "Returns true if 'input' is an abbreviation",
      "syntax": "RiTa.isAbbreviation(input);<br/>RiTa.isAbbreviation(input, caseSensitive);",
      "parameters": [
        {
          "type": "string",
          "desc": "text input"
        },
        {
          "type": "boolean",
          "desc": "caseSensitive (optional, default=false)"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if 'input' is an abbreviation"
        }
      ]
    },
    {
      "name": "isQuestion",
      "example": "RiTa.isQuestion(\"what is this\"); // returns -> true",
      "description": "Returns true if sentence starts with a question word",
      "syntax": "RiTa.isQuestion(sentence);",
      "parameters": [
        {
          "type": "string",
          "desc": "sentence"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if 'sentence' starts with a question word"
        }
      ]
    },
    {
      "name": "isPunctuation",
      "example": "isPunctuation(\"?\"); // returns -> true",
      "description": "Returns true if every character of 'text' is a punctuation character",
      "syntax": "RiTa.isPunctuation(text);",
      "parameters": [
        {
          "type": "string",
          "desc": "text input"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true or false"
        }
      ]
    },
    {
      "name": "randomSeed",
      "example": "seed = 345345;<br/>RiTa.randomSeed(seed);",
      "description": "Sets the seed for RiTa's random number generator",
      "syntax": "RiTa.randomSeed(num);",
      "parameters": [
        {
          "type": "int",
          "desc": "numElements"
        }
      ],
      "returns": [],
      "related": "<a href='../randomWord'>RiTa.randomWord</a>, <a href='../randomOrdering'>RiTa.randomOrdering</a>"
    },
    {
      "name": "randomOrdering",
      "example": "array = RiTa.randomOrdering(5);",
      "description": "Returns a randomly ordered array of unique integers from 0 to numElements. <br/>The size of the array will be numElements.",
      "syntax": "RiTa.randomOrdering(numElements);",
      "parameters": [
        {
          "type": "int",
          "desc": "numElements"
        }
      ],
      "returns": [
        {
          "type": "int[]",
          "desc": "unique integers from 0 to numElements-1"
        }
      ]
    },
    {
      "name": "sentences",
      "example": "RiTa.sentences(\"\"The boy went fishing.\", he said. Then he went away.\");",
      "description": "Splits 'text' into sentences (according to PENN Treebank conventions)",
      "syntax": "RiTa.sentences(text);<br/>RiTa.sentences(text, regex);",
      "parameters": [
        {
          "type": "string",
          "desc": "text the text to be split"
        },
        {
          "type": "string OR Regex (in JS)",
          "desc": "regex (optional) the pattern to be used for word tokenization"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "array of sentences"
        }
      ]
    },
    {
      "name": "addTransform",
      "example": "RiTa.addTransform(\"uc\", (s) => s.toUpperCase());<br/>RiTa.evaluate(\"This.uc() is an acronym.\");",
      "description": "Registers a new RiScript transform function that may then be used in all RiScript evaluations (including within Grammars)",
      "syntax": "RiTa.addTransform(name, function);",
      "parameters": [
        {
          "type": "string",
          "desc": "the input"
        },
        {
          "type": "Function",
          "desc": "the function to call, which should accept and return a string"
        }
      ],
      "returns": [],
      "related": "See RiScript documentation"
    },
    {
      "name": "evaluate",
      "example": "RiTa.evaluate(\"He was (happy | sad | indifferent)\");<br/>RiTa.evaluate(\"He was (happy | sad | \\$emo)\", context);",
      "description": "Parses and executes a RiScript string",
      "syntax": "RiTa.evaluate(string);<br/>RiTa.evaluate(string, context);",
      "parameters": [
        {
          "type": "string",
          "desc": "the input"
        },
        {
          "type": "object",
          "desc": "the JavaScript context for any referenced variables or functions (optional)"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the result of the evaluation"
        }
      ],
      "related": "See RiScript documentation"
    },
    {
      "name": "tokenize",
      "example": "<br/>sentence = \"The doctors treated dogs\";<br/>wordArray = RiTa.tokenize(sentence);<br/>wordArray = RiTa.tokenize(sentence, \"\\\\\\\\s\");<br/><br/>",
      "description": "Tokenizes a string (into words) according to Penn Treebank conventions<br/>See: <a href='ftp://ftp.cis.upenn.edu/pub/treebank/public_html/tokenization.html'>ftp://ftp.cis.upenn.edu/pub/treebank/public_html/tokenization.html</a>",
      "syntax": "RiTa.tokenize(text);<br/>RiTa.tokenize(text, regex);",
      "parameters": [
        {
          "type": "string",
          "desc": "the input"
        },
        {
          "type": "string OR Regex <br/>(in JS)",
          "desc": "regex (optional) the pattern to be used for tokenization"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "in which each element is a single token (or word)"
        }
      ],
      "related": "<a href='../untokenize'>RiTa.untokenize</a>"
    },
    {
      "name": "untokenize",
      "example": "",
      "description": "Joins an array (of words and punctuation) into a string, according to Penn Treebank conventions<br/>See: <a href='ftp://ftp.cis.upenn.edu/pub/treebank/public_html/tokenization.html'>ftp://ftp.cis.upenn.edu/pub/treebank/public_html/tokenization.html</a>",
      "syntax": "RiTa.untokenize(wordArray)",
      "parameters": [
        {
          "type": "string[]",
          "desc": "the input"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "in which the elements have been joined into a single string"
        }
      ],
      "related": "<a href='../tokenize'>RiTa.tokenize</a>"
    },
    {
      "name": "phonemes",
      "example": "<br/>RiTa.phonemes(\"apple\"); // returns -> ae-p-ah-l <br/><br/>RiTa.phonemes(\"two apples\"); // returns -> t-uw ae-p-ah-l-z <br/><br/>",
      "description": "Returns a string containing all <a target=_new href='../../PhonemeTags.php'>phonemes</a> for the input text",
      "syntax": "RiTa.phonemes(wordStr)",
      "parameters": [
        {
          "type": "string",
          "desc": "text to analyze"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "e.g., 'ae-n  eh-l-ax-f-ax-n-t  ih-z  ey  m-ae-m-ax-l'<br/>(for 'An elephant is a mammal')"
        }
      ]
    },
    {
      "name": "pos",
      "example": "<br/>RiTa.pos(\"I am a cat.\"); <br/>// returns -> [ \"prp\", \"vbp\", \"dt\", \"nn\", \".\" ]<br/><br/>",
      "description": "Uses the default PosTagger to tag the input with tags from the <a href='http://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]",
      "syntax": "RiTa.pos(word);<br/>RiTa.pos(word, boolean);",
      "parameters": [
        {
          "type": "string",
          "desc": "the text to be tagged"
        },
        {
          "type": "boolean",
          "desc": "if true, use WordNet style tags (optional, default=false)"
        }
      ],
      "returns": [
        {
          "type": "string[] of part-of-speech tags",
          "desc": ""
        }
      ]
    },
    {
      "name": "posInline",
      "example": "<br/>sentence = \"The doctors treated dogs\";<br/>pos = RiTa.posInline(sentence);<br/><br/>tokenArray = RiTa.tokenize(sentence);<br/>pos = RiTa.posInline(tokenArray);<br/><br/>",
      "description": "Takes an string returns a combined string of the form:<p><pre>'The/dt doctor/nn treated/vbd dogs/nns'</pre> using lowercased tags from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a>",
      "syntax": "RiTa.posInline(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the text to tag"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "a combined string of words and pos tags"
        }
      ]
    },
    {
      "name": "stresses",
      "example": "RiTa.stresses(\"apple\"); // returns -> 1/0",
      "description": "Analyzes the input and returns a new string containing the stresses for each syllable of the input text ",
      "syntax": "RiTa.stresses(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "words to analyze"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "e.g., '01-0-1', with 1's meaning 'stressed', and 0's meaning 'unstressed', "
        }
      ]
    },
    {
      "name": "syllables",
      "example": "RiTa.syllables(\"apple\"); // returns -> ae/p-ah-l",
      "description": "Analyzes the input and returns a string containing the phonemes for each syllable of each word of the input text,  delimited by dashes (phonemes) and spaces (words) ",
      "syntax": "RiTa.syllables(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "words to analyze"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "e.g., 'dh-ax d-ao-g r-ae-n f-ae-s-t' for the 4 syllables of the phrase 'The dog ran fast'"
        }
      ]
    },
    {
      "name": "concordance",
      "example": "// Java<br/><br/>opts = new HashMap();<br/>opts.put(\"ignoreCase\", false);<br/>opts.put(\"ignoreStopWords\", true);<br/><br/>kwic = RiTa.concordance(text, word, opts);<br/><br/><br/>// JavaScript<br/><br/>opts = {<br/> ignoreCase: false,<br/> ignoreStopWords: true<br/>};<br/><br/>kwic = RiTa.concordance(text, word, opts);<br/><br/>",
      "description": "Creates a concordance, a list of words with their frequency of occurence, from the given text and (optional) options",
      "syntax": "RiTa.concordance(text, word, opts);",
      "parameters": [
        {
          "type": "string",
          "desc": "the text"
        },
        {
          "type": "string",
          "desc": "the word to lookup"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional) the relevant options for the KWIK model:<br/><br/>{int} options.wordCount: <br/># of words of context on either side of input word<br/><br/>{boolean} options.ignoreCase:<br/>Ignore upper/lower case in the model <br/><br/>{boolean} options.ignoreStopWords: <br/>Ignore words like 'the', 'and', 'a', 'of', etc, as specified in RiTa.STOP_WORDS<br/><br/>{boolean} options.ignorePunctuation:<br/>Ignore punctuation tokens in the model<br/><br/>{string[]} options.wordsToIgnore:<br/>A set of words (alternative stop-words, for example) to ignore.<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "the concordance"
        }
      ],
      "note": "See <a href=\"https://en.wikipedia.org/wiki/Concordance_%28publishing%29\">https://en.wikipedia.org/wiki/Concordance_%28publishing%29</a>"
    },
    {
      "name": "kwic",
      "example": "// Java<br/><br/>Map opts = new HashMap();<br/>opts.put(\"ignoreCase\", false);<br/>opts.put(\"ignoreStopWords\", true);<br/><br/>string[] lines = RiTa.kwic(text, opts);<br/><br/><br/>// JavaScript<br/><br/>var opts = {<br/> ignoreCase: false,<br/> ignoreStopWords: true<br/>};<br/><br/>var lines = RiTa.kwic(text, opts);<br/><br/>",
      "description": "Creates a Key-Word-In-Context (KWIC) model from a given text, a word to lookup, a wordCount and (optional) options",
      "syntax": "RiTa.kwic(text, word, options);",
      "parameters": [
        {
          "type": "string",
          "desc": "the text"
        },
        {
          "type": "string",
          "desc": "the word to lookup"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional) the relevant options for the KWIC model:<br/><br/>{int} options.wordCount: <br/># of words/punctuation of context on either side of input word<br/><br/>{boolean} options.ignoreCase:<br/>Ignore upper/lower case in the model <br/><br/>{boolean} options.ignoreStopWords: <br/>Ignore words like 'the', 'and', 'a', 'of', etc, as specified in RiTa.STOP_WORDS<br/><br/>{boolean} options.ignorePunctuation:<br/>Ignore punctuation tokens in the model<br/><br/>{string[]} options.wordsToIgnore:<br/>A set of words (alternative stop-words, for example) to ignore.<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "all the occurrences of the keyword in the model, each with 'wordCount' words of context on either side"
        }
      ],
      "note": "See <a href=\"https://en.wikipedia.org/wiki/Concordance_%28publishing%29\">https://en.wikipedia.org/wiki/Concordance_%28publishing%29</a>"
    },
    {
      "name": "conjugate",
      "example": "// JavaScript<br/><br/>opts = {<br/> tense: RiTa.PRESENT_TENSE,<br/> number: RiTa.SINGULAR,<br/> person: RiTa.THIRD_PERSON<br/>};<br/><br/>result = RiTa.conjugate('swim', opts);// Java<br/><br/>opts = new HashMap();<br/>opts.put(\"tense\", RiTa.PAST_TENSE);<br/>opts.put(\"number\", RiTa.SINGULAR);<br/>opts.put(\"person\", RiTa.FIRST_PERSON);<br/><br/>result = RiTa.conjugate(\"swim\", opts);<br/><br/><br/><br/><br/>",
      "description": "Conjugates the 'verb' according to the specified options",
      "syntax": "RiTa.conjugate(verb, opts);",
      "parameters": [
        {
          "type": "string",
          "desc": "the root verb"
        },
        {
          "type": "object",
          "desc": "object containing the relevant options (tense, number, person) for the conjugator"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the conjugated verb"
        }
      ]
    },
    {
      "name": "pastParticiple",
      "example": "RiTa.pastParticiple(\"write\"); // returns -> written",
      "description": "Returns the past participle form of the verb",
      "syntax": "RiTa.pastParticiple(verb);",
      "parameters": [
        {
          "type": "string",
          "desc": "the verb"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the past participle form of the verb"
        }
      ]
    },
    {
      "name": "presentParticiple",
      "example": "RiTa.presentParticiple(\"sit\"); // returns -> sitting",
      "description": "Returns the present participle form of the verb",
      "syntax": "RiTa.presentParticiple(verb);",
      "parameters": [
        {
          "type": "string",
          "desc": "the verb"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the present participle form of the verb"
        }
      ]
    },
    {
      "name": "stem",
      "example": "<br/>s = RiTa.stem(\"cakes\"); // returns -> cake",
      "description": "Extracts base roots from a word according to the Pling stemming algorithm <br/>",
      "syntax": "RiTa.stem(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to analyze"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the stemmed form of the word"
        }
      ]
    },
    {
      "name": "pluralize",
      "example": "<br/>pluralized = RiTa.pluralize(\"dog\"); // returns \"dogs\"<br/><br/>pluralized = RiTa.pluralize(\"mouse\"); // returns \"mice\"<br/><br/>",
      "description": "Pluralizes a noun according to pluralization rules",
      "syntax": "RiTa.pluralize(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the noun"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the (regular or irregular) plural form of the noun"
        }
      ]
    },
    {
      "name": "singularize",
      "example": "<br/>singular = RiTa.singularize(\"dogs\"); // returns \"dog\"<br/><br/>singular = RiTa.singularize(\"mice\"); // returns \"mouse\"<br/><br/>",
      "description": "Singularize a word according to singularization rules",
      "syntax": "RiTa.singularize(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the noun"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the singular form of the noun"
        }
      ]
    },
    {
      "name": "hasWord",
      "example": "RiTa.hasWord(\"apple\");",
      "description": "Returns true if the word exists in the lexicon (case-insensitive)",
      "syntax": "RiTa.hasWord(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "word"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the current lexicon includes the word, else false"
        }
      ]
    },
    {
      "name": "alliterations",
      "example": "RiTa.alliterations(\"cat\"); <br/>RiTa.alliterations(\"cat\", {limit: 10});<br/>RiTa.alliterations(\"cat\", { maxLength: 4, numSyllables: 1 });",
      "description": "Finds alliterations by comparing the phonemes of the input string to those of each word in the lexicon",
      "syntax": "RiTa.alliterations(word);<br/>RiTa.alliterations(word, opts);",
      "parameters": [
        {
          "type": "string",
          "desc": "input word"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "array of alliterations"
        }
      ],
      "related": "<a href='../rhymes'>RiTa.rhymes</a>,<a href='../search'>RiTa.search</a>,<a href='../soundsLike'>RiTa.soundsLike</a>,<a href='../spellsLike'>RiTa.spellsLike</a>"
    },
    {
      "name": "randomWord",
      "example": "// a random word from the lexicon<br/>RiTa.randomWord();<br/><br/>// a random plural noun from the lexicon<br/>RiTa.randomWord({ pos: \"nns\"});<br/><br/>// a random word with 3 syllables and length 3 or 4<br/>RiTa.randomWord({ numSyllables: 3, maxLength: 4});",
      "description": "Returns a random word from the lexicon according to specified options",
      "syntax": "randomWord()<br/>randomWord(opts);",
      "parameters": [
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=4)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string",
          "desc": "the random word"
        }
      ],
      "related": "<a href='../randomSeed'>RiTa.randomSeed</a>"
    },
    {
      "name": "rhymes",
      "example": "RiTa.rhymes(\"cat\"); <br/>RiTa.rhymes(\"cat\", {limit: 10});<br/>RiTa.rhymes(\"cat\", { maxLength: 4, numSyllables: 1 });",
      "description": "Two words are considered as rhyming if their final stressed vowel and all following phonemes are identical",
      "syntax": "RiTa.rhymes(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "word"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "rhymes for the word, or an empty array if none are found"
        }
      ],
      "related": "<a href='../spellsLike'>RiTa.alliterations</a>,<a href='../search'>RiTa.search</a>,<a href='../soundsLike'>RiTa.soundsLike</a>,<a href='../spellsLike'>RiTa.spellsLike</a>"
    },
    {
      "name": "search",
      "example": "RiTa.search();<br/>RiTa.search(\"tting\")",
      "description": "Searches for words in the lexicon that match the given criteria, either by phoneme, stress, or letters. If no regex or options are supplied, the full set of words is returned.",
      "syntax": "RiTa.search()<br/>RiTa.search(regex);<br/>RiTa.search(regex, opts);",
      "parameters": [
        {
          "type": "string",
          "desc": "regex pattern to match (optional)"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "array of words matching the search criteria in the lexicon (or all words if no criteria is provided)"
        }
      ],
      "related": "<a href='../spellsLike'>RiTa.alliterations</a>,<a href='../rhymes'>RiTa.rhymes</a>,<a href='../soundsLike'>RiTa.soundsLike</a>,<a href='../spellsLike'>RiTa.spellsLike</a>"
    },
    {
      "name": "isAdverb",
      "example": "RiTa.isAdverb(\"sleepily\");",
      "description": "Returns true if the word has an adverb form. That is, if any of its possible parts of speech are any variant of an adverb in the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> (e.g. rb, rbr, rbs)",
      "syntax": "RiTa.isAdverb(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as an adverb "
        }
      ]
    },
    {
      "name": "isNoun",
      "example": "RiTa.isNoun(\"cat\");",
      "description": "Returns true if the word has a noun form. That is, if any of its possible parts of speech are any variant of a noun in the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a>(e.g. nn, nns, nnp, nnps)",
      "syntax": "RiTa.isNoun(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as a noun"
        }
      ]
    },
    {
      "name": "isVerb",
      "example": "RiTa.isVerb(\"run\");",
      "description": "Returns true for if word has a verb form. That is, if any of its possible parts of speech are any variant of a verb in the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> (e.g. vb, vbg, vbd, vbp, vbz)",
      "syntax": "RiTa.isVerb(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as a verb"
        }
      ]
    },
    {
      "name": "isAdjective",
      "example": "RiTa.isAdjective(\"cold\");",
      "description": "Returns true if word has an adjective form. That is, if any of its possible parts of speech are any variant of an adjective in the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> (e.g. jj, jjr, jjs)",
      "syntax": "RiTa.isAdjective(word);",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to test"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the word can be used as an adjective"
        }
      ]
    },
    {
      "name": "isAlliteration",
      "example": "RiTa.isAlliteration(\"cat\",\"kitchen\");",
      "description": "Returns true if the two words are alliterations (iff the first stressed consonant of the two match). Note: returns true if wordA.equals(wordB) and false if either (or both) are null.",
      "syntax": "RiTa.isAlliteration(word1, word2);",
      "parameters": [
        {
          "type": "string",
          "desc": "the first word"
        },
        {
          "type": "string",
          "desc": "the second word"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the first stressed consonant of the two words match"
        }
      ]
    },
    {
      "name": "isRhyme",
      "example": "RiTa.isRhyme(\"cat\",\"mat\");",
      "description": "Returns true if the two words rhyme, that is, if their final stressed vowel phoneme and all following phonemes are identical, else false.<br/><br/>Note: returns false if word1.equals(word2) or if either (or both) are null;<br/><br/>",
      "syntax": "RiTa.isRhyme(word1, word2)<br/>RiTa.isRhyme(word1, word2, useLTS);",
      "parameters": [
        {
          "type": "string",
          "desc": "word1"
        },
        {
          "type": "string",
          "desc": "word2"
        },
        {
          "type": "boolean",
          "desc": "use letter-to-sound rules if not found in lexicon (optional, default=true)"
        }
      ],
      "returns": [
        {
          "type": "boolean",
          "desc": "true if the two words rhyme, else false."
        }
      ]
    },
    {
      "name": "soundsLike",
      "example": "RiTa.soundsLike(\"happy\");<br/>RiTa.soundsLike(\"happy\", { matchSpelling: true });<br/>RiTa.soundsLike(\"happy\", { limit: 10, minDistance: 2 });<br/>RiTa.soundsLike(\"happy\", { numSyllables: 2, minDistance: 2 });<br/>RiTa.soundsLike(\"happy\", { minWordLength:10, numSyllables:2 });",
      "description": "Compares the phonemes of the input word (using a version of the Levenstein min-edit distance algorithm) to each word in the lexicon, returning the set of closest matches.",
      "syntax": "RiTa.soundsLike(word)<br/>RiTa.soundsLike(word, opts)",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to match"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{bool} options.matchSpelling: <br/>if true will also attempt to match spelling<br/>by returning an intersection with <a href='../spellsLike'>RiTa.spellsLike</a> (default=false)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>{int} options.minDistance: <br/>the minimum distance of words from the target word<br/>(increase to get more results)<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "the matching words"
        }
      ],
      "related": "<a href='../spellsLike'>RiTa.spellsLike</a>"
    },
    {
      "name": "spellsLike",
      "example": "RiTa.spellsLike(\"happy\");<br/>RiTa.spellsLike(\"happy\", { limit: 10 });<br/>RiTa.spellsLike(\"happy\", { limit: 10, minDistance: 2 });<br/>RiTa.spellsLike(\"happy\", { numSyllables: 2, minDistance: 2 });<br/>RiTa.spellsLike(\"happy\", { minWordLength:10, numSyllables:2 });",
      "description": "Compares the letters of the input word (using a version of the Levenstein min-edit distance algorithm) to each word in the lexicon, returning the set of closest matches.",
      "syntax": "RiTa.spellsLike(word)<br/>RiTa.spellsLike(word, opts)",
      "parameters": [
        {
          "type": "string",
          "desc": "the word to match"
        },
        {
          "type": "object<br/>(or Map in Java)",
          "desc": "options (optional)<br/><br/>{int} options.minLength: <br/>minimum number of characters in target word (default=3)<br/><br/>{int} options.maxLength: <br/>maximum number of characters in target word<br/><br/>{int} options.numSyllables: <br/>target # of syllables in the word<br/><br/>{int} options.limit: <br/>maximum # of results to return<br/><br/>{string} options.pos: <br/>target part-of-speech for the word<br/>either from the <a href='https://rednoise.org/rita/reference/PennTags.html'>PENN tag set</a> or the simplified tag set [a, r, v, n]<br/><br/>{int} options.minDistance: <br/>the minimum distance of words from the target word<br/>(increase to get more results)<br/><br/>"
        }
      ],
      "returns": [
        {
          "type": "string[]",
          "desc": "the matching words"
        }
      ],
      "related": "<a href='../soundsLike'>RiTa.soundsLike</a>"
    }
  ]
}